-- LocalScript trong StarterPlayerScripts ho·∫∑c StarterGui

-- L·∫•y PlayerGui
local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- T·∫°o ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FullScreenOverlay"
screenGui.Parent = playerGui

-- T·∫°o Frame ƒëen ph·ªß k√≠n m√†n h√¨nh
local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0) -- ph·ªß k√≠n m√†n h√¨nh
frame.Position = UDim2.new(0, 0, 0, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- m√†u ƒëen
frame.BorderSizePixel = 0
frame.Parent = screenGui

-- T·∫°o TextLabel ·ªü gi·ªØa
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(0, 400, 0, 100) -- k√≠ch th∆∞·ªõc ch·ªØ
textLabel.Position = UDim2.new(0.5, -200, 0.5, -50) -- cƒÉn gi·ªØa
textLabel.BackgroundTransparency = 1
textLabel.Text = "Normal Working ‚úÖ"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- m√†u tr·∫Øng
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextScaled = true -- ch·ªØ t·ª± ƒë·ªông scale
textLabel.Parent = frame

if shared.__BRAINROT_WEBHOOK_SENT then return end
shared.__BRAINROT_WEBHOOK_SENT = true
-- ================== SETUP ==================
repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local placeId = game.PlaceId

-- ================== CONFIG ==================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1458661734041522178/iQud8T27bN4dC515O6NEQ51SkKz8gv8R__B-g5GnmJAt1idjnX9Kct7DRiOD0FItojUW"
local PRICE_LIMIT = 1_000_000
local MAX_DISTANCE = 5

-- ================== DEBUG ==================
local function debugPrint(...)
	print("[BRAINROT FINDER]", ...)
end

-- ================== PARSE GENERATION ==================
local function parseGeneration(text)
	if not text then return 0 end
	local num = tonumber(text:match("[%d%.]+")) or 0
	if text:find("K") then
		num *= 1e3
	elseif text:find("M") then
		num *= 1e6
	end
	return num
end

-- ================== WORLD POSITION ==================
local function getInstanceWorldPos(inst)
	if inst:IsA("BasePart") then
		return inst.Position
	end
	if inst:IsA("Model") then
		if inst.PrimaryPart then
			return inst.PrimaryPart.Position
		else
			return inst:GetPivot().Position
		end
	end
end

-- ================== GET BASE NAME ==================
local function getBaseNameFromPlot(plot)
	local sign =
		plot:FindFirstChild("PlotSign")
		and plot.PlotSign:FindFirstChild("SurfaceGui")
		and plot.PlotSign.SurfaceGui:FindFirstChild("Frame")
		and plot.PlotSign.SurfaceGui.Frame:FindFirstChild("TextLabel")

	if sign then
		return sign.Text
	end
	return "Unknown Base"
end

-- ================== COLLECT BRAINROT ==================
local function collectBrainrot()
	local found = {}
	local plots = Workspace:FindFirstChild("Plots")
	local debrisFolder = Workspace:FindFirstChild("Debris")

	if not plots or not debrisFolder then
		debugPrint("‚ùå Missing Plots or Debris")
		return found
	end

	for _, plot in ipairs(plots:GetChildren()) do
		debugPrint("üîé Scanning plot:", plot.Name)
		local baseName = getBaseNameFromPlot(plot)

		local podiums = plot:FindFirstChild("AnimalPodiums")
		if not podiums then continue end

		for _, podium in ipairs(podiums:GetChildren()) do
			local att =
				podium:FindFirstChild("Base")
				and podium.Base:FindFirstChild("Spawn")
				and podium.Base.Spawn:FindFirstChild("Attachment")

			if not att then continue end
			local attPos = att.WorldPosition

			local nearest, nearestDist

			for _, debris in ipairs(debrisFolder:GetChildren()) do
				local overhead = debris:FindFirstChild("AnimalOverhead")
				if not overhead then continue end

				local nameLabel = overhead:FindFirstChild("DisplayName")
				local genLabel  = overhead:FindFirstChild("Generation")
				if not nameLabel or not genLabel then continue end

				local debrisPos = getInstanceWorldPos(debris)
				if not debrisPos then continue end

				local dist = (debrisPos - attPos).Magnitude
				if dist <= MAX_DISTANCE and (not nearestDist or dist < nearestDist) then
					nearestDist = dist
					nearest = {
						name = nameLabel.Text,
						genText = genLabel.Text,
						genValue = parseGeneration(genLabel.Text),
						baseName = baseName
					}
				end
			end

			if nearest then
				debugPrint(
					"[MATCH]",
					nearest.name,
					nearest.genText,
					"=>",
					nearest.genValue,
					"| Base:",
					nearest.baseName
				)

				if nearest.genValue >= PRICE_LIMIT then
					table.insert(
						found,
						string.format(
							"%s (%s) | %s",
							nearest.name,
							nearest.genText,
							nearest.baseName
						)
					)
				end
			end
		end
	end

	return found
end

-- ================== WEBHOOK ==================
local function sendWebhook(loot)
	if #loot == 0 then
		debugPrint("‚ùå No valid brainrot")
		return
	end

	local serverLink = ("https://kebabman.vercel.app/start?placeId=%s&gameInstanceId=%s")
		:format(placeId, tostring(game.JobId))

	local payload = {
		content = "@everyone **BRAINROT FOUND!!!!**",
		embeds = {{
			title = "üß† Brainrot Finder",
			color = 16711680,
			fields = {
				{ name = "Loot", value = table.concat(loot, "\n") },
				{ name = "Join Server", value = ("[Click Here](%s)"):format(serverLink) }
			}
		}}
	}

	local req = (syn and syn.request) or http_request or (http and http.request) or request
	if req then
		debugPrint("üì§ Sending webhook")
		req({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = HttpService:JSONEncode(payload)
		})
	end
end

-- ================== MAIN ==================
debugPrint("üöÄ Finder started")

local allBrainrot = {} -- t·∫•t c·∫£ brainrot t√¨m ƒë∆∞·ª£c
local loot = {}         -- ch·ªâ nh·ªØng brainrot ƒë·ªß PRICE_LIMIT ƒë·ªÉ g·ª≠i webhook

-- Collect brainrot
local plots = Workspace:FindFirstChild("Plots")
local debrisFolder = Workspace:FindFirstChild("Debris")

if plots and debrisFolder then
    for _, plot in ipairs(plots:GetChildren()) do
        local baseName = getBaseNameFromPlot(plot)
        local podiums = plot:FindFirstChild("AnimalPodiums")
        if not podiums then continue end

        for _, podium in ipairs(podiums:GetChildren()) do
            local att =
                podium:FindFirstChild("Base")
                and podium.Base:FindFirstChild("Spawn")
                and podium.Base.Spawn:FindFirstChild("Attachment")

            if not att then continue end
            local attPos = att.WorldPosition

            local nearest, nearestDist

            for _, debris in ipairs(debrisFolder:GetChildren()) do
                local overhead = debris:FindFirstChild("AnimalOverhead")
                if not overhead then continue end

                local nameLabel = overhead:FindFirstChild("DisplayName")
                local genLabel  = overhead:FindFirstChild("Generation")
                if not nameLabel or not genLabel then continue end

                local debrisPos = getInstanceWorldPos(debris)
                if not debrisPos then continue end

                local dist = (debrisPos - attPos).Magnitude
                if dist <= MAX_DISTANCE and (not nearestDist or dist < nearestDist) then
                    nearestDist = dist
                    nearest = {
                        name = nameLabel.Text,
                        genText = genLabel.Text,
                        genValue = parseGeneration(genLabel.Text),
                        baseName = baseName
                    }
                end
            end

            if nearest then
                -- Th√™m t·∫•t c·∫£ brainrot v√†o allBrainrot
                table.insert(
                    allBrainrot,
                    string.format("%s (%s) | %s", nearest.name, nearest.genText, nearest.baseName)
                )

                -- Ch·ªâ th√™m v√†o loot n·∫øu ƒë·ªß PRICE_LIMIT
                if nearest.genValue >= PRICE_LIMIT then
                    table.insert(loot, string.format("%s (%s) | %s", nearest.name, nearest.genText, nearest.baseName))
                end
            end
        end
    end
end

-- ================== GUI ==================
-- S·∫Øp x·∫øp allBrainrot theo gi√° tr·ªã t·ª´ l·ªõn xu·ªëng b√©
table.sort(allBrainrot, function(a, b)
    local function parseGen(text)
        local num = tonumber(text:match("%(([%d%.KM]+)%)")) or 0
        if text:find("K") then num = num * 1e3
        elseif text:find("M") then num = num * 1e6
        end
        return num
    end
    return parseGen(a) > parseGen(b)
end)

-- T·∫°o frame ch·ª©a danh s√°ch brainrot
local listFrame = Instance.new("Frame")
listFrame.Size = UDim2.new(0, 400, 0, 0)
listFrame.Position = UDim2.new(0.5, -200, 0.5, 60)
listFrame.BackgroundTransparency = 1
listFrame.Parent = frame

local padding = 5
local currentY = 0
for _, item in ipairs(allBrainrot) do
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 20)
    label.Position = UDim2.new(0, 0, 0, currentY)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.SourceSans
    label.TextScaled = true
    label.Text = item
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.Parent = listFrame

    currentY = currentY + 20 + padding
end
listFrame.Size = UDim2.new(0, 400, 0, currentY)

-- ================== G·ª¨I WEBHOOK ==================
sendWebhook(loot)
textLabel.Text = "Webhook Sent ‚úÖ"

-- ================== SERVER HOP (REAL FIX) ==================
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local placeId = game.PlaceId

task.wait(0.1)
print("üîÅ Server hopping (basic)")
TeleportService:Teleport(placeId, player)
